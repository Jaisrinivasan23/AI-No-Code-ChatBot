<script>
  document.addEventListener('DOMContentLoaded', () => {
    const contactList = document.getElementById('contact-list');
    const searchBar = document.getElementById('search-bar');
    const conversationArea = document.getElementById('conversation');
    const chatInput = document.getElementById('chat-input');
    let currentSenderId = null;  // Track the currently open chat

    // Fetch and render profiles from the database every time
    function fetchAndRenderProfiles() {
      fetch('/api/profiles')
        .then(response => response.json())
        .then(data => {
          renderContacts(data);
        })
        .catch(error => console.error('Error fetching profiles:', error));
    }

    // Render profiles in contact list
    function renderContacts(profiles) {
      contactList.innerHTML = '';
      profiles.forEach(profile => {
        const li = document.createElement('li');
        const profileImage = document.createElement('div');
        profileImage.className = 'profile-image';
        profileImage.textContent = profile.name.charAt(0);  // Display first letter of profile name

        li.appendChild(profileImage);
        li.appendChild(document.createTextNode(profile.name));
        
        // On click, open chat for the selected profile
        li.addEventListener('click', () => {
          currentSenderId = profile.sender_id;
          openChat(profile.name, profile.sender_id);
        });
        contactList.appendChild(li);
      });
    }

    // Fetch and open chat with all messages from the database
    function openChat(contactName, senderId) {
      document.getElementById('profile-name').textContent = contactName;
      conversationArea.innerHTML = '';  // Clear current messages
      currentSenderId = senderId;  // Update the current sender

      // Fetch all messages for the user from the database
      fetch(`/api/chat/${senderId}`)
        .then(response => response.json())
        .then(data => {
          renderMessages(data);  // Display fetched messages in UI
        })
        .catch(error => console.error('Error fetching conversation:', error));
    }

    // Render all messages in the conversation area
    function renderMessages(chatMessages) {
      conversationArea.innerHTML = '';  // Clear previous messages
      chatMessages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.className = msg.type === 'user' ? 'message received' : 'message sent';

        const contentSpan = document.createElement('span');
        contentSpan.className = 'content';
        contentSpan.textContent = msg.text;

        const timestampSpan = document.createElement('span');
        timestampSpan.className = 'timestamp';
        timestampSpan.textContent = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        messageDiv.appendChild(contentSpan);
        messageDiv.appendChild(timestampSpan);
        conversationArea.appendChild(messageDiv);
      });
      conversationArea.scrollTop = conversationArea.scrollHeight;
    }

    // Send a new message and immediately display it in the UI
    function sendMessage() {
      const messageText = chatInput.value.trim();
      if (!messageText || !currentSenderId) return;  // Ensure a sender is selected

      // Display the message immediately in the UI
      displayMessage(messageText, true);

      // Send the message to the backend
      fetch('/api/send_message', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sender_id: currentSenderId, message: messageText })
      })
      .then(response => {
        if (!response.ok) {
          console.error('Error sending message');
        }
      })
      .catch(error => console.error('Error sending message:', error));

      chatInput.value = '';  // Clear input field
    }

    // Display a new message in the conversation area
    function displayMessage(content, isSentByUser) {
      const messageDiv = document.createElement('div');
      messageDiv.className = isSentByUser ? 'message sent' : 'message received';

      const contentSpan = document.createElement('span');
      contentSpan.className = 'content';
      contentSpan.textContent = content;

      const timestampSpan = document.createElement('span');
      timestampSpan.className = 'timestamp';
      timestampSpan.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      messageDiv.appendChild(contentSpan);
      messageDiv.appendChild(timestampSpan);
      conversationArea.appendChild(messageDiv);
      conversationArea.scrollTop = conversationArea.scrollHeight;
    }

    // Send message on Enter key press
    chatInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        sendMessage();
        event.preventDefault();
      }
    });
  
      // Handle microphone recording (if applicable)
      let mediaRecorder;
      let audioChunks = [];
  
      function startRecording() {
        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(stream => {
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.start();
            mediaRecorder.addEventListener('dataavailable', event => {
              audioChunks.push(event.data);
            });
            mediaRecorder.addEventListener('stop', () => {
              const audioBlob = new Blob(audioChunks, { type: 'audio/mp3' });
              const audioUrl = URL.createObjectURL(audioBlob);
              displayAudioMessage(audioUrl);
              audioChunks = [];
            });
  
            recordBtn.style.display = 'none';
            stopBtn.style.display = 'inline';
          })
          .catch(error => console.error('Error accessing microphone:', error));
      }
  
      function stopRecording() {
        if (mediaRecorder) {
          mediaRecorder.stop();
        }
        recordBtn.style.display = 'inline';
        stopBtn.style.display = 'none';
      }
  
      function displayAudioMessage(audioUrl) {
        const audio = document.createElement('audio');
        audio.controls = true;
        audio.src = audioUrl;
        const audioContainer = document.createElement('div');
        audioContainer.className = 'voice-message';
        audioContainer.appendChild(audio);
        conversationArea.appendChild(audioContainer);
        conversationArea.scrollTop = conversationArea.scrollHeight;
      }
  
      recordBtn.addEventListener('click', startRecording);
      stopBtn.addEventListener('click', stopRecording);
  
      // Handle file uploads
      cameraIcon.addEventListener('click', () => fileInput.click());
  
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          displayFileMessage(file);
        }
      });
  
      function displayFileMessage(file) {
        let fileElement;
        const fileType = file.type;
  
        if (fileType.startsWith('image/')) {
          const img = document.createElement('img');
          img.src = URL.createObjectURL(file);
          img.alt = file.name;
          img.className = 'uploaded-image';
          fileElement = img;
        } else if (fileType.startsWith('video/')) {
          const video = document.createElement('video');
          video.src = URL.createObjectURL(file);
          video.controls = true;
          video.className = 'uploaded-video';
          fileElement = video;
        } else if (fileType.endsWith('pdf') || fileType.endsWith('doc') || fileType.endsWith('docx')) {
          const docMessage = document.createElement('div');
          docMessage.className = 'document-message';
  
          const docIcon = document.createElement('div');
          docIcon.className = 'document-icon';
          docIcon.textContent = 'ğŸ“„';
  
          const docDetails = document.createElement('div');
          docDetails.className = 'document-details';
  
          const docFilename = document.createElement('div');
          docFilename.className = 'document-filename';
          docFilename.textContent = file.name;
  
          const docFilesize = document.createElement('div');
          docFilesize.className = 'document-filesize';
          docFilesize.textContent = `${(file.size / 1024 / 1024).toFixed(2)} MB`;
  
          const downloadLink = document.createElement('a');
          downloadLink.className = 'document-download';
          downloadLink.href = URL.createObjectURL(file);
          downloadLink.textContent = 'Download';
          downloadLink.download = file.name;
  
          docDetails.appendChild(docFilename);
          docDetails.appendChild(docFilesize);
          docDetails.appendChild(downloadLink);
          docMessage.appendChild(docIcon);
          docMessage.appendChild(docDetails);
          fileElement = docMessage;
        }
  
        if (fileElement) {
          const messageDiv = document.createElement('div');
          messageDiv.className = 'message sent';
          messageDiv.appendChild(fileElement);
          const timestampSpan = document.createElement('span');
          timestampSpan.className = 'timestamp';
          timestampSpan.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          messageDiv.appendChild(timestampSpan);
          conversationArea.appendChild(messageDiv);
          conversationArea.scrollTop = conversationArea.scrollHeight;
        }
      }
  
      // Handle selected messages for deletion
      let selectedMessages = [];
      function toggleSelection(event) {
        const message = event.currentTarget;
        const messageId = message.dataset.messageId;
  
        if (selectedMessages.includes(messageId)) {
          message.classList.remove('selected');
          selectedMessages = selectedMessages.filter(id => id !== messageId);
        } else {
          message.classList.add('selected');
          selectedMessages.push(messageId);
        }
        toggleDeleteOptions();
      }
  
      function toggleDeleteOptions() {
        const deleteOptions = document.getElementById('delete-options');
        deleteOptions.style.display = selectedMessages.length > 0 ? 'flex' : 'none';
      }
  
      function deleteMessages(deleteForEveryone) {
        selectedMessages.forEach(messageId => {
          const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
          if (messageElement) {
            messageElement.remove();
          }
        });
        selectedMessages = [];
        toggleDeleteOptions();
      }
  
      conversationArea.addEventListener('click', (event) => {
        if (event.target.closest('.message')) {
          toggleSelection(event);
        }
      });
  
      document.getElementById('delete-for-me').addEventListener('click', () => deleteMessages(false));
      document.getElementById('delete-for-everyone').addEventListener('click', () => deleteMessages(true));
    });
  </script>
  